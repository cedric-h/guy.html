<!-- vim: sw=2 ts=2 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>guy.html</title>
    <style> document, body { margin: 0px; padding: 0px; overflow: hidden; } </style>
  </head>
  <body>
    <div id="container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">

import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

const fbx = fetch("./Walking.fbx").then(x => x.arrayBuffer());

fbx.then(bytes => {
  const model = new FBXLoader().parse(bytes);

  const skeleton = new THREE.SkeletonHelper(model);

  const anim = model.animations[0];

  /* look at animation and find fps */
  let fps, anim_times;
  {
      anim_times = new Set();

      for (const track of anim.tracks) {
          for (const time of track.times) {
              anim_times.add(time);
          }
      }

      console.assert(anim_times.has(0), 'expected 0 to be timestamp present in animation');
      console.assert(anim_times.has(anim.duration), `expected ${anim.duration} to be timestamp present in animation`);
      anim_times.delete(anim.duration);

      anim_times = [...anim_times].sort((a, b) => a - b);

      /* check that the frames in the animation are more or less evenly spaced */
      {
        const times = [...anim_times];
        const approx_eq = (a, b) => Math.abs(a - b) < 0.0001;
        if (!times.slice(1).reduce((a, x, i) => (a > 0) ? approx_eq(a, x - times.at(i)) : x - times.at(i), 0))
          alert("frames in animation not evenly spaced ðŸ¤”");
      }

      fps = anim_times.length / anim.duration;
  }


  /* look at skeleton and find connections, joint positions */
  const connections = [];
  {
      const walk_bones = (parent, bone) => {
          if (parent && bone && (parent.name != bone.name))
            connections.push([parent.name, bone.name]);
          
          for (const child of bone.children) {
              walk_bones(bone, child);
          }
      }
      walk_bones(null, model.children.find(x => x.isBone));
  }

  /* extract each frame of the animation */
  const frames = [];
  {
    const scale = new THREE.Matrix4();
    scale.elements = [
        0.01,  0.00, 0.00, 0.00,
        0.00,  0.00, 0.01, 0.00,
        0.00, -0.01, 0.00, 0.00,
        0.00,  0.00, 0.00, 1.00
    ];

    const mixer = new THREE.AnimationMixer(model);

    const action = mixer.clipAction(anim);
    action.play();

    let strip = ({ x, y, z }) => ({ x, y, z });

    for (const time of anim_times) {
      mixer.setTime(time);

      const frame = {};
      const bones_seen = new Set();
      for (const bone of skeleton.bones) {
        if (bones_seen.has(bone.ID)) continue;
        bones_seen.add(bone.ID);

        const p = strip(bone.position.clone().applyMatrix4(scale));
        frame[bone.name] = p;
      }
      frames.push(frame);
    }
  }

  const out = { fps, duration: anim.duration, connections, frames };
  console.log(out);

});
    </script>

  </body>
</html>
